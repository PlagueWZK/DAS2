# 王政凯答辩文档（后端与部署）

## 负责范围
- 后端架构与接口设计（`app.py`）
- 文件上传、输出目录管理与安全校验
- 批量并行处理与任务结果组织
- 打包与部署配置（`app.spec`、`render.yaml`）

## 关键实现要点
- 采用 Flask 提供轻量 Web 服务，接口简单清晰
- 上传文件使用 UUID 命名，避免重名冲突
- 使用 `ThreadPoolExecutor` 并行处理，提高批量性能
- 通过 `MAX_CONTENT_LENGTH` 限制上传大小，避免异常负载
- 统一输出目录，方便结果下载与打包

## 可能问题与回答

### Q1：为什么选择 Flask 而不是更重的框架？
A：项目目标是快速实现上传、处理、下载的流程，Flask 轻量、学习成本低，部署简单，非常适合该规模的 Web 工具型应用。

### Q2：如何保证多文件上传时不重名？
A：上传后使用 `uuid` 前缀与原文件名组合生成唯一文件名，避免覆盖，同时保留原名用于展示。

### Q3：并行处理如何实现？是否存在线程安全问题？
A：使用 `ThreadPoolExecutor` 并发处理不同文件，增强操作在不同线程运行。进度统计通过 `task_lock` 保护共享字典，避免竞态。

### Q4：如何保证上传文件安全？
A：在后端进行扩展名白名单过滤，同时设置最大上传大小；上传路径经过 `secure_filename` 处理。

### Q5：为什么预览要返回 Base64？
A：前端页面无需额外静态目录配置，通过接口直接返回 Base64 能简化展示逻辑与权限控制。

### Q6：打包与部署如何做？
A：本地使用 `pyinstaller app.spec` 打包；云端使用 `render.yaml`，由 Gunicorn 启动 Flask 应用。

### Q7：如果大批量图片会出现什么瓶颈？
A：主要是内存与 CPU 使用率，Base64 预览也会增加响应体积。可通过限制并发数或改为分页预览进行优化。

### Q8：为什么上传目录和输出目录在运行时创建？
A：应用可能在不同环境运行（本地/打包/云端），启动时自动创建目录可以避免因路径缺失导致的写入失败。

### Q9：接口异常如何处理与反馈？
A：各接口使用 `try/except` 捕获异常，返回统一的 JSON 错误信息，前端可直接展示失败原因。

### Q10：生产环境为什么用 Gunicorn 启动？
A：Gunicorn 是成熟的 WSGI 服务，支持多进程/多 worker，稳定性与性能优于 Flask 内置开发服务器。

### Q11：处理结果的返回顺序如何保证？
A：异步处理后使用索引映射回填结果列表，确保返回顺序与上传顺序一致，便于前端对齐展示。

### Q12：上传与输出文件如何清理？
A：当前版本不自动清理，便于答辩与调试；后续可通过定时任务或按用户会话回收。

## 答辩展示建议
- 先演示上传与增强流程
- 强调并行处理与文件管理细节
- 说明部署方式（本地/Render）与打包流程


